require "./header"
module PDF
  # 最小的PDF文档必须包含许多基本部分：
  #
  # - trailer字典，提供有关如何阅读其余内容的信息文件中的对象
  # - 文档目录，它是对象图的根。
  # - 页面树，它枚举文档中的页面。
  # - 至少有一页。每个页面必须具有：
  # - - resources(资源)，包括例如字体。
  # - - 其页面内容，其中包含绘制文本和图形的说明在页面上。
  #
  # 另一种说法是:一个简单有效的PDF文件按顺序包含四个部分:
  #
  # - header，提供PDF版本号
  # - body 包含页面，图形内容和大部分辅助信息的主体，全部编码为一系列对象。
  # - 交叉引用表，列出文件中每个对象的位置便于随机访问。
  # - trailer包括trailer字典，它有助于找到文件的每个部分， 并列出可以在不处理整个文件的情况下读取的各种元数据。
  class Document
    #提供PDF版本号
    @header : Header
    #包含页面，图形内容和大部分辅助信息的主体，全部编码为一系列对象。
    @body=0
    #交叉引用表，列出文件中每个对象的位置便于随机访问。
    @crossrefs =0
    #trailer字典，它有助于找到文件的每个部分， 并列出可以在不处理整个文件的情况下读取的各种元数据。
    @trailers =0
    def initialize(@header,@boty,@crossrefs,@trailers)
    end

    # 将PDF文档写入文件中的一系列字节要比阅读它简单得多， 我们不需要支持所有PDF格式，只需要支持我们打算使用的子集。写作 PDF文件非常快，因为它只是将对象图展平为一系列字节。
    #
    #- 输出header。
    #- 删除PDF中任何其他对象未引用的任何对象。这个避免编写不再需要的对象。
    #- 重新编号对象，使它们从1到n运行，其中n是对象的数量文件。
    #- 逐个输出对象，从对象编号1开始，记录字节交叉引用表的每个偏移量。
    #- 编写交叉引用表。
    #- 编写trailer，trailer字典和文件结束标记
    def render(io : IO)
      @header.render(io)

      io<<"%%EOF"
    end
  end
end
    